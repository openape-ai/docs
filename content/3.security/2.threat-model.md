---
title: Threat Model
description: Security analysis and design decisions.
---

# Threat Model

## Email as Public Input

The user's email is entered at the SP to trigger DNS discovery. This is inherently visible to the SP — an accepted, unclosable information surface.

**Why it's OK:** The email is needed for DNS resolution (`_ddisa.{domain}`). Passkeys ensure that knowing someone's email is insufficient to impersonate them. This is the same model as email itself — knowing an address doesn't give you access.

## Minimal AuthN-JWT

The identity token contains only:
- `sub` — email (consistent from input to token)
- `act` — `human` or `agent`
- `iss`, `aud`, `exp`, `nonce`

Explicitly **not** in the AuthN-JWT:
- Name, display name → IdP-internal
- Owner, approver → AuthZ layer (grants)

**Rationale:** AuthN says *who*. AuthZ says *what may they do*. Mixing them increases token size and leaks information the SP doesn't need.

## Grant Security

### Command Hash Binding

For `apes` and similar tools, grants are bound to the exact command via SHA-256:

```
cmd_hash = sha256("apt-get upgrade")
```

The target system computes the hash locally and compares. If it doesn't match, execution is aborted. This prevents:
- **Substitution attacks** — approving "whoami" but executing "rm -rf /"
- **Replay with different commands** — the hash won't match

### Dual Accountability

Grants track both the **agent's identity** and the **approver's identity** separately. In many setups, the agent owner and the approver are different people:

- Agent owner: the person responsible for the agent
- Approver: the person who approved this specific action

Both are recorded in the AuthZ-JWT (`sub` + `decided_by`).

### Default Deny

No grant = no access. Agents start with zero permissions and must request each one. There is no "admin agent" concept — every privileged action requires explicit human approval (or a standing grant).

### Management Token Separation

The IdP Management Token (`NUXT_OPENAPE_MANAGEMENT_TOKEN`) is an **infrastructure credential** — equivalent to a database root password or a cloud provider's admin key. It belongs exclusively to human administrators and must never be accessible to agents.

**Why this boundary is critical:**

If an agent obtains the Management Token, it can bypass the entire grant system:

1. **Self-registration** — create new agent identities without human approval
2. **Grant self-approval** — approve its own privilege requests
3. **Identity forgery** — register arbitrary agents and issue tokens for them
4. **Audit destruction** — the grant log becomes meaningless because the approver and requester are the same entity

This is not a theoretical risk — it is the single most important security boundary in an OpenApe deployment. The grant system's value depends entirely on the separation between *who administers the IdP* (humans with the Management Token) and *who requests permissions through it* (agents with Ed25519 keys).

**Correct deployment:**

- Store the Management Token in a secrets manager or environment variable accessible only to the deployment infrastructure
- Never write it into agent configuration files, shell histories, or automation scripts that agents can read
- Use separate credentials for CI/CD pipelines — if a pipeline needs IdP access, give it a scoped API key, not the Management Token

**Anti-patterns:**

- Passing the Management Token as a CLI argument to agent processes
- Storing it in a shared `.env` file on a machine where agents run
- Using the Management Token "temporarily" for agent enrollment (use the enrollment URL flow instead)

## Credential Overview

| Credential | Who holds it | Purpose | Agent access? |
|---|---|---|---|
| Management Token | Human admin | IdP administration | **NEVER** |
| Ed25519 Private Key | Agent (via `apes`) | Agent authentication | Yes (auto-generated, not exportable) |
| Passkey | Human user | Human authentication | Hardware-bound |
| Session Secret | Deployment | Cookie signing | Infrastructure only |
